-- Databricks notebook source
-- MAGIC %md # 1. Data Ingestion and Transformation with DLT
-- MAGIC In this notebook, we'll use [Delta Live Tables](https://www.databricks.com/product/delta-live-tables) to:
-- MAGIC - Ingest data from configurable sources
-- MAGIC - Apply business and data quality rules
-- MAGIC - Create feature sets for machine learning
-- MAGIC
-- MAGIC ***NOTE!** If this pipeline fails, check the schemas for data and run the [Data_Generation_Notebook].*

-- COMMAND ----------

-- MAGIC %md 
-- MAGIC ##1.1 Bronze -> Silver
-- MAGIC We're now ready to ingest data from our data generators. [Delta Live Tables](https://www.databricks.com/product/delta-live-tables) allows us to define our ingestion logic using declarative statements.
-- MAGIC
-- MAGIC Ingested data is written into the **bronze layer** of our Delta Lake. Because we want to ensure high throughput from our data sources, we load the data in its original format. We add some metadata (e.g. ingestion timestamps) during this phase.
-- MAGIC
-- MAGIC In this scenario, the data we generated is landing in our Delta lake as a Bronze table.  So this DLT pipeline will be working to create the Silver and Gold Tables that are necessary.

-- COMMAND ----------

-- MAGIC %md ###1.1.1 Well Data Silver
-- MAGIC First we'll ingest dimension data about our wells into a Silver table.  Here we can add in DQ checks, do any filtering we might need, etc.
-- MAGIC
-- MAGIC
-- MAGIC
-- MAGIC ***NOTE!** Materialized Views are fully recomputed whenever a DLT update is executed. They're especially useful for loading smaller dimension tables with less-frequent updates.*

-- COMMAND ----------

CREATE OR REFRESH MATERIALIZED VIEW 
  all_wells_silver  (
  CONSTRAINT valid_api EXPECT (API_NUMBER IS NOT NULL) ON VIOLATION DROP ROW
)
COMMENT 
  "Contains all active wells both planned and unplanned.  Includes infromation such as API, Depth, Field, etc.  Shold be used as basis for all analysis"
AS SELECT
  *
FROM {{.catalog}}.{{.schema}}.all_wells_bronze
;

-- COMMAND ----------

-- MAGIC %md ###1.1.2 Drilling Job Phase Silver
-- MAGIC
-- MAGIC We can use a similar pattern to ingest job phase data related to the wells.  We will apply some DQ checks to ensure API number is present for all rows and join to the wells table to add well name a well_name_column.  We will additionally filter all wells that have the status aas "Planned".

-- COMMAND ----------

CREATE OR REFRESH MATERIALIZED VIEW drilling_job_phase_silver (

  CONSTRAINT valid_api EXPECT(API_NUMBER IS NOT NULL) ON VIOLATION DROP ROW
)
COMMENT " dataset provides time and depth measurements for drilling, casing, and cementing phases across different job stages (Rig Move, Surface, Intermediate, and Production). It can be leveraged for Rate of Penetration (ROP) calculations and Days vs Depth charts."
AS
SELECT
  b.WELL_NAME,
  b.SPUD_DATE,
  b.PRODUCING_FORMATION,
  a.*,
  -- ROUND(DATEDIFF(a.end_time, a.start_time), 2) AS DURATION_DAYS,
  CAST(DATEDIFF(SECOND, a.start_time, a.end_time) / 86400.0 AS DECIMAL(10, 2)) AS DURATION_DAYS
FROM
  {{.catalog}}.{{.schema}}.drilling_job_phase_bronze a
    inner join LIVE.all_wells_silver b
      on a.API_NUMBER = b.API_NUMBER
where
  b.CURRENT_STATUS != 'Planned';

-- COMMAND ----------

-- MAGIC %md ###1.1.3 Drilling NPT Silver
-- MAGIC
-- MAGIC We can use a similar pattern to ingest job phase data related to the wells.

-- COMMAND ----------

CREATE OR REFRESH MATERIALIZED VIEW drilling_npt_silver (

  CONSTRAINT valid_api EXPECT(API_NUMBER IS NOT NULL) ON VIOLATION DROP ROW
)
COMMENT "Contains all NPT data related to the drilling job for a particular API number.  For each record gives information on type, depth, and estimated cost"
AS
SELECT
  b.WELL_NAME, a.*
FROM
  {{.catalog}}.{{.schema}}.drilling_npt_bronze a
    inner join LIVE.all_wells_silver b
      on a.API_NUMBER = b.API_NUMBER
where
  b.CURRENT_STATUS != 'Planned';

;

-- COMMAND ----------

-- MAGIC %md ###1.1.4 Drilling Cost Silver
-- MAGIC
-- MAGIC We can use a similar pattern to ingest job phase data related to the wells.

-- COMMAND ----------

CREATE OR REFRESH MATERIALIZED VIEW drilling_cost_silver (

  CONSTRAINT valid_api EXPECT(API_NUMBER IS NOT NULL) ON VIOLATION DROP ROW
)
COMMENT "dataset generates information typically captured in SAP and references various accounts budgeted for on an Authorization for Expenditure (AFE). It can be used to compare well costs at the account level, with costs slightly correlated to Total Depth (TD)."
AS
SELECT
    b.WELL_NAME, a.*
FROM
  {{.catalog}}.{{.schema}}.drilling_cost_bronze a
    inner join LIVE.all_wells_silver b
      on a.API_NUMBER = b.API_NUMBER
where
  b.CURRENT_STATUS != 'Planned';

;

-- COMMAND ----------

-- MAGIC %md ###1.2 Silver -> Gold
-- MAGIC Gold tables are fit for business case tables that are highly aggregated and specific for use within dashboards or models.  These tables apply business logic to ensure dashbaords and downstream use cases are extremely fast and reliables

-- COMMAND ----------

-- MAGIC %md ###1.2.1 Drilling Job Summary Table
-- MAGIC
-- MAGIC Table aggregates summary metrics related to the drilling job such as total npt, cost, ROP, righ move, etc.

-- COMMAND ----------

CREATE OR REFRESH MATERIALIZED VIEW drill_job_summary_gold (

  CONSTRAINT valid_api EXPECT(API_NUMBER IS NOT NULL) ON VIOLATION DROP ROW
)
COMMENT "This table aggregates data at the job level of detial and will be used in dashboard to display high level kpis of each job."
AS
with j as (Select
        API_NUMBER,
        Max(END_DEPTH) as TOTAL_DEPTH_DRILLED,
        Sum(DURATION_DAYS) as DAYS_ON_LOCATION
      from
        LIVE.drilling_job_phase_silver
      group by
        API_NUMBER) ,
n as (Select
        API_NUMBER,
        SUM(NPT_DURATION_MIN) as TOTAL_NPT_MIN,
        Sum(NPT_ESTIMATED_COST) as TOTAL_NPT_COST
      from
        LIVE.drilling_npt_silver
      group by
        API_NUMBER) ,
c as (   Select
        API_NUMBER,
        SUM(ACTUAL_COST) as TOTAL_ACTUAL_COST
      from
        LIVE.drilling_cost_silver
      group by
        API_NUMBER) 
Select
  a.API_NUMBER,
  a.WELL_NAME,
  a.LONGITUDE,
  a.LATITUDE,
  a.PRODUCING_FORMATION,
  a.SPUD_DATE,
  a.GEO_RISK_INDEX,
  j.TOTAL_DEPTH_DRILLED,
  j.DAYS_ON_LOCATION,
  j.TOTAL_DEPTH_DRILLED/j.DAYS_ON_LOCATION as ROP,
  n.TOTAL_NPT_MIN,
  n.TOTAL_NPT_COST,
  n.TOTAL_NPT_COST/j.TOTAL_DEPTH_DRILLED as NPT_COST_PER_FOOT,
  n.TOTAL_NPT_MIN/j.TOTAL_DEPTH_DRILLED as NPT_MIN_PER_FOOT,
  c.TOTAL_ACTUAL_COST,
  c.TOTAL_ACTUAL_COST/j.TOTAL_DEPTH_DRILLED as COST_PER_FOOT
from
  LIVE.all_wells_silver a
    inner join  j
      on a.API_NUMBER = j.API_NUMBER
    inner join  n
      on a.API_NUMBER = n.API_NUMBER
    inner join  c
      on a.API_NUMBER = c.API_NUMBER
where
  SPUD_DATE is not null;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ###1.2.2 Drilling TIME Model Table
-- MAGIC
-- MAGIC This table is built to be used by our time model and will combine cost level data at the account data with metrics such as TD, Field, Formation.  It will be leveraged by our MLFlow model to predict time based on various inputs

-- COMMAND ----------

CREATE OR REFRESH MATERIALIZED VIEW drill_time_model_gold (

  CONSTRAINT valid_api EXPECT(API_NUMBER IS NOT NULL) ON VIOLATION DROP ROW
)
COMMENT "This table is built to be used by our time model and will combine cost level data at the account data with metrics such as TD, Field, Formation.  It will be leveraged by our MLFlow model to predict time based on various inputs."
AS
SELECT
  w.API_NUMBER,
  w.PRODUCING_FORMATION,
  w.FIELD_NAME,
  DATEDIFF(CURRENT_DATE(), w.SPUD_DATE) as DAYS_FROM_SPUD,
  w.GEO_RISK_INDEX,
  j.JOB_PHASE,
  j.JOB_SUB_PHASE,
  j.DURATION_DAYS as DURATION_DAYS,
   MAX(j.END_DEPTH) OVER(PARTITION BY j.API_NUMBER, j.JOB_PHASE) - MIN(j.START_DEPTH) OVER(PARTITION BY j.API_NUMBER, j.JOB_PHASE) as JOB_PHASE_DEPTH
FROM
  LIVE.drilling_job_phase_silver j
    inner join LIVE.all_wells_silver w
      on j.API_NUMBER = w.API_NUMBER;

-- COMMAND ----------

-- MAGIC %md
-- MAGIC ###1.2.3 Drilling Cost Model Table
-- MAGIC This table is built to be used by our cost table and will combine cost level data at the account data with metrics such as TD, Field, Formation.  It will be leveraged by our MLFlow model to predict cost based on various inputs.

-- COMMAND ----------

CREATE OR REFRESH MATERIALIZED VIEW
  drill_cost_model_gold (
    CONSTRAINT valid_api EXPECT (API_NUMBER IS NOT NULL) ON VIOLATION DROP ROW
  )
COMMENT
  "This table is built to be used by our cost table and will combine cost level data at the account data with metrics such as TD, Field, Formation.  It will be leveraged by our MLFlow model to predict cost based on various inputs."
AS SELECT
  w.API_NUMBER,
  w.PRODUCING_FORMATION,
  w.GEO_RISK_INDEX,
  w.FIELD_NAME,
  DATEDIFF(CURRENT_DATE(), w.SPUD_DATE) as DAYS_FROM_SPUD,
  w.TOTAL_DEPTH,
  c.COST_DESC,
  c.ACTUAL_COST
FROM
  LIVE.drilling_cost_silver c
    inner join LIVE.all_wells_silver w
      on c.API_NUMBER = w.API_NUMBER;
